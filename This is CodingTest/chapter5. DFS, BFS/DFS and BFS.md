## DFS / BFS
**그래프를 탐색**하기 위한 대표적인 두 가지 알고리즘

### 1. 꼭 필요한 자료구조 기초
* 자료구조
    * 데이터를 표현하고 관리하고 처리하기 위한 구조
    * `push()`: 데이터를 삽입
    * `pop()`: 데이터를 삭제
    * 스택과 큐를 사용할 대는 **오버플로**와 **언더플로**까지 고려할 것!  
    

* 스택
    * 선입후출
    * 별도의 라이브러리 사용할 필요 X
        * 기본 리스트에서 `append()`와 `pop()` 매서드 사용
```buildoutcfg
stack = []

# 삽입(5) - 삽입(2) - 삭제()
stack.append(5)
stack.append(2)
stack.pop()

print(stack) # 최하단 원소부터 출력
print(stack[::-1]) # 최상단 원소부터 출력
```

* 큐
  * 선입선출
  * `collections` 모듈에서 제공하는 `deque` 자료구조 활용
  * `dequeue`
    * 스택과 큐의 장점을 모두 채택
    * 데이터를 넣고 빼는 속도가 리스트보다 효율적
    * `queue` 라이브러리를 사용하는 것보다 간단함
  * `deque` 객체를 리스트 자료형으로 변경
    * `list()` 메서드 사용!
```buildoutcfg
# 큐(Queue) 구현을 위해 deque 라이브러리 사용
from collections import deque

queue = deque()

# 삽입(5) - 삽입(2) - 삭제()
queue.append(5)
queue.append(2)
queue.popleft()

print(queue) # 먼저 들어온 순서대로 출력
queue.reverse() # 다음 출력을 위해 역순으로 바꾸기
print(queue) # 나중에 들어온 원소부터 출력
```

* 재귀함수
  * 자기 자신을 다시 호출하는 함수
  * 재귀함수의 종료 조건
    * 재귀함수에서는 반드시 재귀함수의 **종료조건을 명시**해야됨!
  * 재귀함수는 내부적으로 스택 자료구조와 동일
  
### 탐색 알고리즘 DFS/ BFS
* 그래프의 두 가지 표현 방식
    * 인접 행렬: **2차원 배열**로 그래프의 연결 관계를 표현하는 방식
    * 인접 리스트: 리스트로 그래프의 연결 관계를 표현하는 방식
      * 연결 리스트라는 자료구조를 사용하여 구현
      * 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용
      * 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느림
        * 특정 노드와 연결된 모든 인접 노드 순회
        
```인접 행렬 방식
# 인접 행렬 방식 예제
INF = 999999999 # 무한의 비용 선언

# 2차원 리스트를 이용해 인접 행렬 표현
graph = [
    [0, 7, 5],
    [7, 0, INF],
    [5, INF, 0]
]
```

```buildoutcfg
# 인접 리스트 방식 예제

# 행(Row)이 3 개인 2차원 리스트로 인접 리스트 표현
graph = [[] for _ in range(3)]

# 노드 0에 연결된 노드 정보 저장(노드, 거리)
graph[0].append((1, 7))
graph[0].append((2, 5))

# 노드 1에 연결된 노드 정보 저장(노드, 거리)
graph[1].append((0, 7))

# 노드 2에 연결된 노드 정보 저장(노드, 거리)
graph[2].append((0, 5))
```


* DFS
  * 깊이 우선 탐색
  * **스택** 자료구조 사용
  > 1. 탐색 시작 노드를 스택에 삽입하고 방문 처리
  > 2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드에 스택을 넣고 방문처리. 방문처리 하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냄
  > 3. 이전 과정을 더 이상 수행할 수 없을 때까지 반복
```buildoutcfg
# DFS 메서드 정의
def dfs(graph, v, visited):
    # 현재 노드를 방문 처리
    visited[v] = True
    print(v, end = ' ')
    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:
        dfs(graph, i, visited)
      
# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
graph = [
       [],
       [2, 3, 8],
       [1, 7],
       [1, 4, 5],
       [3, 5]
       [3, 4],
       [7],
       [2, 6, 8],
       [1, 7]
       ]
  
# 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
visited = [False] * 9

# 정의된 DFS 함수 호출
dfs(graph, 1, visited)
```

* BFS
  * 너비 우선 탐색(가까운 노드부터 탐색하는 알고리즘)
  * 큐 자료구조 이용
  > 1. 탐색 시작 노드를 큐에 삽입하고 방문처리
  > 2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리 함
  > 3. 이전 과정을 더 이상 수행할 수 없을 때까지 반복
```buildoutcfg
# BFS 예제
from collections import deque

# BFS 메서드 정의
def bfs(graph, start, visited):
    # 큐(Queue) 구현을 위해 deque 라이브러리 사용
    queue = deque([start])
    # 현재 노드를 방문 처리
    visited[start] =True
    # 큐가 빌 때까지 반복
    while queue:
        # 큐에서 하나의 원소를 뽑아 출력
        v = queue.leftpop()
        print(v, end = ' ')
        # 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
        for i in graph[v]:
            if not visited[i]:
            queue.append(i)
            visited[i] = True

# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
graph = [
   [],
   [2, 3, 8],
   [1, 7],
   [1, 4, 5],
   [3, 5]
   [3, 4],
   [7],
   [2, 6, 8],
   [1, 7]
   ]
  
# 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
visited = [False] * 9

# 정의된 BFS 함수 호출
bfs(graph, 1, visited)
```

* 2차원 배열에서의 탐색 문제를 그래프 형태로 바꿔서 생각하면 풀이를 좀 더 쉽게 할 수 있음!!